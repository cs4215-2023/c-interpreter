\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color,soul}
\usepackage{tikz}
\usepackage{listings, lstautogobble}
\usepackage{xcolor}
\usepackage{url}
\usepackage{hyperref}
\usepackage{multirow}

% For code listing %
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Rule Commands
\newcommand{\Rule}[2]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}}
\newcommand{\Rulee}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[#3]}
\newcommand{\RuleWithName}[3]{\genfrac{}{}{0.7pt}{}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#1$}}}{{\setlength{\fboxrule}{0pt}\setlength{\fboxsep}{3mm}\fbox{$#2$}}}[\text{#3}]}
\newcommand{\transition}{\rightrightarrows_s}
\newcommand{\translate}{\twoheadrightarrow}
\newcommand{\translateaux}{\hookrightarrow}
\newcommand{\Return}{\texttt{return}}
\newcommand{\Recfun}{\texttt{recfun}}
\newcommand{\If}{\texttt{if}}
\newcommand{\Then}{\texttt{then}}
\newcommand{\Else}{\texttt{else}}
\newcommand{\End}{\texttt{end}}
\newcommand{\Let}{\texttt{const}}
\newcommand{\In}{\texttt{in}}
\newcommand{\Rc}{\texttt{\}}}
\newcommand{\Lc}{\texttt{\{}}
\newcommand{\Times}{\texttt{*}}
\newcommand{\Plus}{\texttt{+}}
\newcommand{\TruE}{\texttt{true}}
\newcommand{\FalsE}{\texttt{false}}
\newcommand{\Int}{\texttt{int}}
\newcommand{\Float}{\texttt{float}}
\newcommand{\String}{\texttt{string}}
\newcommand{\Char}{\texttt{char}}
\newcommand{\Num}{\texttt{numeric}}
\newcommand{\Contract}{\texttt{contract}}
\newcommand{\Bool}{\texttt{bool}}
\newcommand{\Undefined}{\texttt{undefined}}
\newcommand{\X}{\texttt{x}}
\newcommand{\F}{\texttt{f}}
\newcommand{\LET}{\texttt{LET}}
\newcommand{\END}{\texttt{END}}
\newcommand{\IN}{\texttt{IN}}
\newcommand{\eval}{\rightarrowtail}
\newcommand{\evaL}{\rightarrowtail}
\newcommand{\partfun}{\rightsquigarrow}
\newcommand{\under}{\Vdash}
\newcommand{\ErroR}{\bot}
\newcommand{\Rp}{\texttt{)}}
\newcommand{\Lp}{\texttt{(}}
\newcommand{\Rb}{\texttt{\}}}
\newcommand{\Lb}{\texttt{\{}}
\newcommand{\blame}{\texttt{blame }}
\newcommand{\flatCon}{\texttt{con}}
\newcommand{\funCon}{\texttt{con1} \rightarrow \texttt{con2}}
\newcommand{\isFlat}{\texttt{flat}}
\newcommand{\conA}{\texttt{con1}}
\newcommand{\conB}{\texttt{con2}}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=false,
    captionpos=b,
    keepspaces=false,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    autogobble=true
}

\lstset{style=mystyle}

\evensidemargin 35pt % Align even and odd numbered pages
\setlength{\parindent}{0in} % Paragraph Indentation
\setlength{\parskip}{\medskipamount} % Spaces between paragraphs

% Horizontal Margins
\setlength{\oddsidemargin}{-0.25in} % Left margin 1 inch (0 + 1)
\setlength{\textwidth}{6.75in} % Text width 6.5 inch (so right margin 1 inch).

% Vertical Margins
\setlength{\topmargin}{-0.75in} % Top margin 0.5 inch (-0.5 + 1)
\setlength{\headheight}{0.25in} % Head height 0.25 inch (where page headers go)
\setlength{\headsep}{0.25in} % Head separation 0.25 inch (between header and top line of text)
\setlength{\textheight}{10.25in} % Text height 8.5 inch (so bottom margin 1.5 in)

\title{A Realistic Explicit Control Evaluator for C}
\author{Lui Wen-Jie, Benjamin (A0214362N), Lester Leong }
\date{April 2022}

\begin{document}
\pagenumbering{gobble}% Remove page numbers (and reset to 1)

% Cover Page %
\begin{titlepage}
    \begin{center}
        \vspace*{1cm}

        \LARGE
        \textbf{A Realistic Explicit Control Evaluator for C}

        \vspace{0.5cm}        
		Project report for \textbf{CS4215}

        \vspace{3cm}

        \Large
        \textbf{Lester Leong (), \\Lui Wen-Jie, Benjamin (A0214362N)}\\
        School of Computing\\
        National University of Singapore\\
        April 2022

		\vspace{3cm}
		\small
		Frontend: \url{https://github.com/cs4215-2023/CS4215-frontend} \\
		Language Processor: \url{https://github.com/cs4215-2023/c-interpreter}

		\vfill

    \end{center}
\end{titlepage}

\tableofcontents
\newpage

\pagenumbering{arabic}
\section{Introduction}

% Outline of the scope and objectives of the project.
C is a programming language that has memory models present such as stack and heap. Thus, we decided to implement a realistic explicit control evaluator for C (RECEC) to align closely with the memory models present. 

The first section, Section 2, will cover the features implemented. The second main section, Section 3, will include the technical specification of our RECEC.

\subsection{T-Diagrams}

T-diagrams of all major language processing steps that the project utilizes

\section{Features}
\label{user}

% Description of how the system can be built using the repository (or repositories) Description of test cases and how to run them: Make sure you include at least 10 test cases that cover the main features of the system. Clear specification of the envisioned deliverable (informal or formal)
% Description to what extent the objectives are met

This section will list the various features that were implemented and certain design choices that we made. The system can be built and tested by following the instructions of the language processor repository, followed by the frontend repository accordingly. Alternatively, one can use the dedicated code editor at \url{https://cs4215-2023.github.io/CS4215-frontend/}. Note that if there is no output on right panel, the return value should be taken as \texttt{NaN}.


The main entry point of each program is a \texttt{main} function \textbf{without any arguments}. This is implicitly called by the interpreter itself. Also note that comments are currently \textbf{not supported}, but for the clarity of code examples, they will be use just like how it is implemented in C. Not that these examples are \textbf{not valid programs} in RECEC because of the comments present.  

\subsection{Primitive Type}
\label{types}
RECEC supports the basic types present in C, primarily, \texttt{int}, \texttt{void}, \texttt{float}, \texttt{char}. These types can be defined with their respective pointer and array types. 

An example of types in RECEC:

\begin{verbatim}
	int a;
	float a[];
	char* a_pter;
\end{verbatim}

\subsection{Basic Operators}
RECEC supports various basic operators.

\begin{itemize}
	\item Unary \texttt{!}, \texttt{\&}, \texttt{*}, \texttt{+} and \texttt{-}.
	\item Arithmetic operators \texttt{+}, \texttt{-}, \texttt{/}, \texttt{*}, \texttt{\%}
	\item Bitwise operators \texttt{\&}, \texttt{|}, \texttt{\^},  \texttt{>>}, \texttt{<<}
	\item Logical operators \texttt{\&\&}, \texttt{||}, \texttt{\^}
	\item Update operators \texttt{++}, \texttt{--}
\end{itemize}

This is an example of how basic operators are used in RECEC: 

\begin{verbatim}
	!(1); // 0
	!(0); // 1
	int a = 1;
	&a; // Gives address of variable a
	*a; // Dereference variable a
	a++; // Variable a contains the value of 2
\end{verbatim}

As we are not supporting \texttt{\_bool\_} type of C, logical operators and unary \texttt{!} will give an integer value of \texttt{1} if \texttt{true} and \texttt{0} otherwise. 

For equality checking, \texttt{==} and \texttt{!=}, we check if the values are the same, regardless of whether they have the same address or not.

\subsection{Variable and Function Declarations}
Each variable declaration must come with a type. The valid types are present in \ref{types} section. This flexibility, however, is not the same for function declarations. 

For function declarations, only the basic types are allowed. If the return type is \texttt{char}, return values of characters will be converted to their respective ascii value. 

Here is an example of some variable and function declarations used in RECEC: 

\begin{verbatim}
	int* a;
	int a[4] = {1,2,3,4};
	char foo() {
		return 'a'; // returns 97
	}
\end{verbatim}

\subsection{Conditionals}

There are 2 types of conditionals in C, namely \texttt{if-else} statements and conditional expressions. Example conditionals can be written as so:

\begin{verbatim}
	int a = 1;
	// if-else statement
	if (a == 0) {
		// do something
	} else {
		// do something else
	}

	// conditional expressions
	a == 0 ? 2 : 3;
\end{verbatim}

\subsection{Loops}

Similar to C, this sublanguage also implements the 3 main loops found in C, namely the for-loop, while loop and the do-while loop. These loops do not return any values at the end if there are no \texttt{return} statements within the body of the loop itself. Furthermore, loops do implement intermediate control functionalities such as \texttt{continue} and \texttt{break}, however, \texttt{return} statements can be used in loops. 

In the case of for loops, \textbf{all initialization, condition and update components are required}. Here are examples of each of the loop:

\begin{verbatim}
	// for loop
	for (int i = 0; i < 10; i++) {
		// do something
	}

	while (i--) {
		// do something
	}

	do {
		// something
	} while (i--);
\end{verbatim}

\subsection{Arrays}
Arrays in RECEC have 2 main requirements. Firstly, the type declarations cannot contain pointer or another array type declaration. Secondly, if an array is initialised, all the values should be of the same type with no variables in it. This could be better explained with a sample program here:

\begin{verbatim}
	int a[] = {1, 2}; // valid array
	int b = 2;
	int c[] = {1, b}; // invalid array; presence of variable in array
	int* d[]; // invalid array; array of pointers
\end{verbatim}

\subsection{Pointers}

Like C, arrays are pointers as well. Simple pointer arithmetic is supported such as \texttt{++}. However, more complex operations such as \texttt{*(c + 1)} is currently not supported. The dereferencing of pointers works similarly to the C language. 

The address that a pointer points to is taken to be an \texttt{int} type. This value will be represented in base 10 instead instead of the usual hexadecimal representation. 

\begin{verbatim}
	int a = 1;
	int* a_pter = &a;
	*a_pter; // value of 1
	a_pter++;
	*a_pter; // value of 2
\end{verbatim}

\subsection{Builtins}

RECEC supports 3 primary builtin functions, namely, \texttt{printf}, \texttt{malloc} and \texttt{free}.

\subsubsection{\texttt{printf}}

\texttt{printf} prints to the console instead of the UI display. To view the result of printf, one is required to look at the console itself to see the value printed. Format specifiers supported by \texttt{printf} are \texttt{"\%c"},\texttt{"\%d"} and \texttt{"\%f"}. Type casting is done here as well, based on the format specifier provided in the input string. Note that the input \textbf{must be a string}. 

Here are some sample \texttt{printf} in RECEC:
\begin{verbatim}
	printf("hello world");
	printf("hello worl%d", 3); // prints hello worl3
	printf("%d", 1.0); // prints  1
\end{verbatim}

\subsubsection{\texttt{malloc}}

TODO

\subsubsection{\texttt{free}}

TODO 


\subsection{Type Checking}

In RECEC, type checking is done before evaluation takes place. This means that the typechecker parses the entire program and check \textbf{every line} for its type. If there is a mismatch in types, the type checker throws a type error. Unlike C where warnings are thrown when a type mismatched is detected, RECEC will terminate the program instead.

The following are some implicit type casting examples that works in RECEC:

\begin{verbatim}
	2.0/ 4; // evaluates to a float type
	int a = 4 + 'a' // evaluates to an int
	char b = 4 + 'b' // evaluates to a char
\end{verbatim}

\section{Specifications}

In this section, we define the semantics of RECEC and describe the implementation of  RECEC in detail.

For steps on running RECEC program, please refer to Section \ref{user}.
Once again, you can find the latest tagged release of RECEC at \url{}, and follow the instructions in the README to setup RECEC to run locally.

We first begin by defining the syntax of RECEC.
We then bring in the type system and define it using static semantics.
This is then synergised with how our interpreter behaves, described using the framework of structural operational semantics.
Finally, we explain how the memory management is performed in RECEC.

\subsection{Syntax}

We divide the syntax of RECEC into three categories, \textit{expressions} and \textit{statements}.

\addtolength{\jot}{-0.5mm}
\begin{alignat*}{9}
    && \textit{program}    &&\quad ::= &\quad && \textit{statement} ... && \textrm{program} \\[1mm]
    && \textit{statement}  &&\quad ::= &\quad && \textit{expression} \ \textbf{\texttt{;}} && \textrm{expression statement} \\
	&&                       && |   &\quad && \textbf{\texttt{return}}\  \textit{expression} \ \textbf{\texttt{;}} && \textrm{return statement}\\
	&&                       && |   &\quad && \textit{if-statement} \quad && \textrm{conditional statement}\\
	&&                       && |   &\quad && \textbf{\texttt{while}}\  \textbf{\texttt{(}}\  \textit{expression} \ \textbf{\texttt{)}} \ \textit{block} && \textrm{while loop}\\
	&&						 && |	&\quad && \textbf{\texttt{do}} \ \textit{block} \ \textbf{\texttt{while}}\  \textbf{\texttt{(}}\  \textit{expression} \ \textbf{\texttt{)}} \ \textbf{\texttt{;}} && \textrm{do-while loop}\\
	&&						 && | 	 &\quad && \textbf{\texttt{for}}\  \textbf{\texttt{(}}\  \textit{expression} \ \textbf{\texttt{;}} \ \textit{expression} \ \textbf{\texttt{;}} \ \textit{expression} \ \textbf{\texttt{)}} \ \textit{block} \ \ \  && \textrm{for loop}\\
	&&						&& 	| &\quad && \textit{type}\  \textit{name} \ \textbf{\texttt{(}}\  \textit{parameters} \ \textbf{\texttt{)}}\ \textit{block} \quad
							&& \textrm{function declaration}\\
\end{alignat*}




\subsubsection{Expressions} 






\subsection{Memory}

TODO

\subsubsection{Stack}

TODO

\subsubsection{Heap}

TODO

\end{document}